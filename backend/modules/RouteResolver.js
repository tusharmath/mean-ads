// Generated by CoffeeScript 1.9.1
var ControllerFactory, ErrorPool, MeanError, Q, V1, _, config, di, express, newrelic, ref,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

express = require('express');

_ = require('lodash');

config = require('../config/config');

newrelic = require('newrelic');

ControllerFactory = require('../factories/ControllerFactory');

di = require('di');

Q = require('q');

ref = require('../config/error-codes'), ErrorPool = ref.ErrorPool, MeanError = ref.MeanError;

V1 = (function() {
  function V1(ctrlFac) {
    this.router = bind(this.router, this);
    this._actionMiddleware = bind(this._actionMiddleware, this);
    this.Controllers = ctrlFac.Controllers;
  }

  V1.prototype._resolveRoute = function(ctrl, ctrlName, actionName) {
    var method, ref1, ref2, route, routeFunc;
    if (!ctrl.actions) {
      throw new MeanError("actions have not been set for controller: " + ctrlName);
    }
    if (!((ref1 = ctrl.actions.actionMap) != null ? ref1[actionName] : void 0)) {
      throw new MeanError("actionMap has not been set for action: " + ctrlName + ": " + actionName);
    }
    ref2 = ctrl.actions.actionMap[actionName], method = ref2[0], routeFunc = ref2[1];
    route = routeFunc(ctrlName.toLowerCase());
    return {
      method: method,
      route: route
    };
  };

  V1.prototype._catch = function(req, res, err) {
    var unknownErr;
    bragi.log('error', err.stack);
    if (err.name === 'ValidationError') {
      return res.status(400).send(err);
    }
    switch (err.type) {
      case 'mean':
        return res.status(err.httpStatus).send(err);
      case 'ObjectId':
        err = ErrorPool.INVALID_OBJECT_ID;
        return res.status(err.httpStatus).send(err);
      case 'date':
        err = ErrorPool.INVALID_DATE;
        return res.status(err.httpStatus).send(err);
      default:
        if (config.newrelic.notify) {
          newrelic.noticeError(err);
        }
        unknownErr = ErrorPool.UNKNOWN_ERROR;
        return res.status(unknownErr.httpStatus).send(unknownErr);
    }
  };

  V1.prototype._actionMiddleware = function(ctrl, action, req, res) {
    var err;
    try {
      return action.call(ctrl.actions, req, res).then(function(doc) {
        return res.send(doc);
      })["catch"]((function(_this) {
        return function(err) {
          return _this._catch(req, res, err);
        };
      })(this)).done();
    } catch (_error) {
      err = _error;
      return this._catch(req, res, err);
    }
  };

  V1.prototype._actionBinder = function(router, ctrl, ctrlName, action, actionName) {
    var method, ref1, route;
    ref1 = this._resolveRoute(ctrl, ctrlName, actionName), method = ref1.method, route = ref1.route;
    bragi.log('api', bragi.util.print("[" + (method.toUpperCase()) + "]"), route);
    return router[method](route, _.curry(this._actionMiddleware, 4)(ctrl, action));
  };

  V1.prototype._forEveryAction = function(router, controllers) {
    return _.each(controllers, (function(_this) {
      return function(ctrl, ctrlName) {
        return _.forIn(ctrl.actions, function(action, actionName) {
          if (!action || actionName[0] !== '$') {
            return;
          }
          return _this._actionBinder(router, ctrl, ctrlName, action, actionName);
        });
      };
    })(this));
  };

  V1.prototype._otherRoutes = function(router) {
    return router.use('*', function(req, res) {
      var err404;
      err404 = ErrorPool.NOTFOUND_RESOURCE;
      return res.status(err404.httpStatus).send(err404.message);
    });
  };

  V1.prototype.router = function() {
    var router;
    router = new express.Router();
    this._forEveryAction(router, this.Controllers);
    this._otherRoutes(router);
    return router;
  };

  return V1;

})();

di.annotate(V1, new di.Inject(ControllerFactory));

module.exports = V1;
