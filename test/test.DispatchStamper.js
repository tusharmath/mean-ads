// Generated by CoffeeScript 1.9.1
var Injector, config;

Injector = require('di').Injector;

config = require('../backend/config/config');

describe('DispatchStamper:', function() {
  beforeEach(function() {
    this.injector = new Injector;
    this.mod = this.injector.getModule('modules.DispatchStamper', {
      mock: false
    });
    return this.date = this.injector.getModule('providers.DateProvider');
  });
  describe("_getMaxDispatchCount", function() {
    return it("returns config.maxDispatchStampCount", function() {
      return this.mod._getMaxDispatchCount().should.equal(config.maxDispatchStampCount);
    });
  });
  describe("parseStamp()", function() {
    it("returns an array", function() {
      return this.mod.parseStamp('aaa111:120,bbb222:2,ccc333:3334').length.should.equal(3);
    });
    it("contains subscription", function() {
      var stamps;
      stamps = this.mod.parseStamp('aaa111:120,bbb222:2,ccc333:3334');
      return stamps[0].subscription.should.equal('aaa111');
    });
    it("contains timestamp", function() {
      var stamps;
      stamps = this.mod.parseStamp('aaa111:120,bbb222:2,ccc333:3334');
      return stamps[0].timestamp.should.be.a('date');
    });
    it("sets timestamp in date format", function() {
      var stamps;
      stamps = this.mod.parseStamp('aaa111:120,bbb222:2,ccc333:3334');
      return stamps[0].timestamp.should.deep.equal(new Date(120));
    });
    it("returns empty array if its a mean error", function() {
      return this.mod.parseStamp('').should.deep.equal([]);
    });
    it("returns empty array if stampStr is null", function() {
      return this.mod.parseStamp(null).should.deep.equal([]);
    });
    return it("throws if its not a mean error", function() {
      return expect((function(_this) {
        return function() {
          return _this.mod.parseStamp('a:aasd');
        };
      })(this)).to["throw"]("Can not parse dispatch timestamp");
    });
  });
  describe("_reduce()", function() {
    it("reduces", function() {
      return this.mod._reduce('', {
        subscription: 'asd123',
        timestamp: new Date(234123123)
      }).should.equal('asd123:234123123');
    });
    return it("adds a comma", function() {
      return this.mod._reduce('lop:098', {
        subscription: 'asd123',
        timestamp: new Date(234123123)
      }).should.equal('lop:098,asd123:234123123');
    });
  });
  describe("appendStamp()", function() {
    beforeEach(function() {
      sinon.stub(this.mod, '_getMaxDispatchCount').returns(3);
      this.date.now.returns(new Date(1001001));
      return this.mockDispatch = {
        subscription: 'asd123NEW'
      };
    });
    it("pushes the timestamp to empty string", function() {
      return this.mod.appendStamp('', this.mockDispatch).should.equal('asd123NEW:1001001');
    });
    it("concatinates with the timestamp to already set stamps", function() {
      return this.mod.appendStamp('asd456OLD:2002002', this.mockDispatch).should.equal('asd123NEW:1001001,asd456OLD:2002002');
    });
    it("removes the first one if maxDispatchStampCount has been achieved", function() {
      return this.mod.appendStamp('a:1,b:2,c:3,d:4', this.mockDispatch).should.equal('c:3,d:4,asd123NEW:1001001');
    });
    it("doesnt remove any the stamp count matches maxDispatchStampCount", function() {
      return this.mod.appendStamp('a:1,b:2', this.mockDispatch).should.equal('a:1,b:2,asd123NEW:1001001');
    });
    return it("updates present timestamps", function() {
      this.mockDispatch.subscription = 'a';
      return this.mod.appendStamp('a:1,b:2', this.mockDispatch).should.equal('b:2,a:1001001');
    });
  });
  describe("_updateOrAddNewStamp()", function() {
    beforeEach(function() {
      this.mStamps = [
        {
          subscription: 1,
          timestamp: 100
        }, {
          subscription: 2,
          timestamp: 200
        }, {
          subscription: 3,
          timestamp: 300
        }, {
          subscription: 4,
          timestamp: 400
        }, {
          subscription: 5,
          timestamp: 500
        }
      ];
      return sinon.stub(this.mod, '_getMaxDispatchCount').returns(3);
    });
    it("adds a new timestamp", function() {
      var newStamp;
      newStamp = {
        subscription: 6,
        timestamp: 600
      };
      this.mod._updateOrAddNewStamp(this.mStamps, newStamp);
      return this.mStamps[5].should.equal(newStamp);
    });
    it("updates old timestamp", function() {
      var newStamp;
      newStamp = {
        subscription: 3,
        timestamp: 789
      };
      this.mod._updateOrAddNewStamp(this.mStamps, newStamp);
      return this.mStamps[2].timestamp.should.equal(789);
    });
    return it("converts toString() before checking", function() {
      var newStamp;
      newStamp = {
        subscription: '3',
        timestamp: 789
      };
      this.mod._updateOrAddNewStamp(this.mStamps, newStamp);
      return this.mStamps[2].timestamp.should.equal(789);
    });
  });
  describe("_removeOldStamps()", function() {
    beforeEach(function() {
      this.mStamps = [
        {
          subscription: 3,
          timestamp: 300
        }, {
          subscription: 2,
          timestamp: 200
        }, {
          subscription: 1,
          timestamp: 100
        }, {
          subscription: 5,
          timestamp: 500
        }, {
          subscription: 4,
          timestamp: 400
        }
      ];
      return sinon.stub(this.mod, '_getMaxDispatchCount').returns(3);
    });
    it("maintains MaxDispatchCount", function() {
      return this.mod._removeOldStamps(this.mStamps).length.should.equal(3);
    });
    it("removes from the oldest timestamps", function() {
      return this.mod._removeOldStamps(this.mStamps).should.deep.equal([
        {
          subscription: 3,
          timestamp: 300
        }, {
          subscription: 4,
          timestamp: 400
        }, {
          subscription: 5,
          timestamp: 500
        }
      ]);
    });
    return it("should not remove anything", function() {
      this.mStamps = [
        {
          subscription: 'a',
          timestamp: 1
        }, {
          subscription: 'b',
          timestamp: 2
        }
      ];
      return this.mod._removeOldStamps(this.mStamps).should.deep.equal(this.mStamps);
    });
  });
  return describe("isConvertableSubscription()", function() {
    beforeEach(function() {
      sinon.stub(this.mod, '_getConversionMaxAge').returns(20);
      return this.date.now.returns(new Date(250));
    });
    it("is yes if subscriptionId is present and time hasnt expired", function() {
      return this.mod.isConvertableSubscription("a:1,b:240.c:3", 'b').should.be["true"];
    });
    it("is no if subscriptionId is NOT present", function() {
      return this.mod.isConvertableSubscription("a:1,b:2.c:3", 'd').should.be["false"];
    });
    return it("is no if timestamp has expired", function() {
      return this.mod.isConvertableSubscription("a:1,b:200.c:3", 'b').should.be["false"];
    });
  });
});
